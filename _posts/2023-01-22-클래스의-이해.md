---
title: 클래스의 이해
author: 9mande
date: 2023-01-22 23:01:00 +0900
categories: [Study]
tags: [java, oop]
---


# 클래스의 이해

## Intro

자바의 클래스를 공부해본다.

자바를 공부하면 객체지향 프로그래밍이 뭔지, 먼저 객체가 뭔지 알아야 한다. 자바에서는 클래스를 통해 객체를 나타낸다.

## I. 클래스 기초

- **객체(Object)란**
    
    객체란 **물리적인 사물**이나 **추상화** 된 것 중에서 다른 것들과 구별될 수 있는 속성을 가진 것
    
    Ex) 물리적인 사물 : 자동차(속성: 바퀴, 속도, ...) / 추상화 된 것 : 예약(속성: 일시, 장소, ...)
    
    자바에서는 객체를 **클래스**를 통해 ****나타낸다.
    
    **인스턴스**는 클래스를 통해 생성되어 메모리에 데이터가 저장되어 있고, 사용할 수 있는 상태의 객체를 말한다.
    
- **클래스란, 클래스의 구조**
    
    클래스는 객체를 표현하기 위해 작성하는 명세서 or 설계도 이다. 필드와 메소드로 나뉘어져 있다.
    
    **필드**는 객체의 **데이터**, **상태** 같은 **속성을** 정의하고, 변수들이 사용된다.
    
    **메서드**는 객체의 **동작**, **기능**의 **작동 방식**을 정의하고, 함수들이 사용된다.
    
    이 두 가지를 **멤버**라고 하고, 각각 멤버 변수, 멤버 함수라고 할 수도 있다.
    
    예시) 자동차는 바퀴가 4개 있어야 하고, 속도라는 속성을 가질 수 있다. 이런 속성들은 필드에 저장된다. 또, ‘자동차를 가속한다’는 동작은 속도를 증가 시키는 것으로 구현할 수 있고, ‘자동차를 멈춘다’는 동작은 속도를 0으로 맞추는 것으로 구현할 수 있다. 이런 작동 방식들은 메서드에 저장된다.
    
- **패키지란**
    
    클래스의 이름이 겹치는 경우 같은 공간에 저장될 수 없고, 구별해서 접근할 수도 없다.
    
    패키지를 사용하면 저장 공간을 분리하고, 접근 방법도 분리될 수 있다.
    
    보통 com.company.department 형태로 사용한다. 패키지 이름은 모두 소문자로 구성한다.
    
    import를 통해 불러온 패키지에 대해 클래스 이름 만으로 사용 가능하다.
    
- **오버로딩이란**
    
    자바에서 함수 이름이 같아도, 나머지 함수의 시그니처가 다른 함수들을 구현할 수 있다.
    
    함수의 시그니처는 함수의 이름, 매개변수의 개수, 매개변수의 타입으로 이루어진다.
    
- **생성자란**
    
    클래스를 통해 객체를 생성할 때 자동으로 호출되는 **첫 번째** 메서드.
    
    따로 구현하지 않으면 **디폴트 생성자**가 만들어진다.
    
    오버로딩이 가장 많이 적용되는 예시.
    
    특이하게, 동일한 클래스의 객체를 인수로 받아서 값을 복제하는 **복제 생성자**의 형태도 있다.
    
- **메모리 공간**
    
    JVM에서, 메모리 영역은 크게 메서드 영역, 스택 영역, 힙 영역으로 나뉜다. 클래스의 각 요소가 어디에 저장되는 지 살펴본다.
    
    자바 **바이트코드**, **static** 클래스 변수는 **메서드 영역**에 저장된다. 생명 주기는 프로그램 시작 전부터 프로그램 종료 까지다.
    
    매개변수, 지역변수는 **스택 영역**에 저장된다. 프로그램 실행 도중에 임시로 생성되었다가, 해당 변수가 포함된 메서드가 종료되면 소멸된다.
    
    **인스턴스**는 **힙 영역**에 저장된다. 힙 영역은 **Garbage Collection**의 대상이 된다. 왜냐면 어떤 인스턴스가 어떠한 참조 변수에도 참조되지 않으면 그 인스턴스는 사용되지 않음이 확실하기 때문이다. Garbage Collection을 통해 대상으로 인식이 되어도, 당장 소멸하진 않는다.
    
- **접근 제한자**
    
    private, protected, public, default(지정하지 않는) 4가지
    
    1. 클래스
        
        public: 어디서든 인스턴스 생성 가능
        
        default: 같은 패키지의 클래스 내에서만 인스턴스 생성 가능
        
    2. 인스턴스 멤버
        
        public: 어디서든 접근 가능
        
        protected: 같은 패키지의 클래스와, 그 클래스의 하위 클래스 내에서 접근 가능
        
        default: 같은 패키지의 클래스 내부에서만 접근 가능
        
        private: 클래스 내부에서만 접근 가능
        

## II. 상속과 다형성 - 오버라이딩, 추상 클래스, 인터페이스

- **상속**
    
    상위클래스의 모든 것이 하위클래스에게 전달되는 것 (private 멤버 제외)
    
    객체 간 계층 구조를 만든다.
    
    코딩 면에서는 재사용성, 확장하기 쉽고 유지보수에 좋다.
    
    자바에서 extends, 다중 상속은 x
    
- **오버라이딩**
    
    상속된 메서드와 시그니처가 같은 메서드를 정의해서 덮어쓰는 것
    
    하위클래스에서 상위클래스의 메서드를 다시 정의하는 것
    
    추상 클래스와 함께, 확장성에 많은 도움을 준다.
    
- **static이란**
    
    멤버(필드와 메서드)에 붙이는 제한자
    
    **static 멤버의 특징**
    
    - 프로그램 시작 전 메모리 로딩
    - 오브젝트 생성 없이 사용 가능
    - 참조하기 위해 클래스 명을 사용한다.
    
    같은 클래스의 오브젝트들은 static 필드의 값을 공유한다.
    
    **static 메서드**
    
    : static 메서드는 오버라이딩 할 수 없고, 같은 클래스 내의 static 멤버만 접근할 수 있다.
    
    **static 초기화 블록**
    
    : static 변수가 메모리 공간에 할당될 때 실행된다.
    
    main이 static인 이유 설명해보기
    
- **추상 클래스**
    
    : 추상 메서드를 포함하는 클래스
    
    **추상 메서드**: 처리 내용을 기술하지 않은 메서드
    
    추상클래스의 하위클래스는 추상메서드를 오버라이딩해야 한다.
    
    만들어야 하는 메서드의 목록이 추상화되어 있으면 가져다 쓰기 쉽다.
    
- **인터페이스**
    
    상속 관계가 아닌 클래스에 기능을 제공하는 구조
    
    정의와 추상 메서드만이 멤버가 될 수 있다. 이때, 정의는 무조건 public static final, 메서드는 무조건 public abstract이고 생략 가능하다.
    
    인터페이스는 클래스에서 구현해야 한다. (implements)
    
    인터페이스도 상속 가능하다. (extends) 클래스에서는 단일 상속만 가능한데 인터페이스에서는 다중 상속이 가능하다.
    
- **다형성**
    
    하나의 오브젝트와 메서드가 많은 형태를 가지고 있는 것.
    
    **오버로딩**, **오버라이딩**에서 메서드가 여러 형태를 갖는 것도 다형성이 구현된 한 예시다.
    
    **상속**에서도 하위클래스 객체를 상위클래스 객체 참조 변수가 참조하게 할 수 있는 것으로 다형성을 드러낼 수 있다.
    
    그 역은 되지 않는다.
    
    하위클래스 타입으로 생성된 객체를 상위클래스 객체 참조 변수가 참조하게 한 경우 다시 하위클래스로 형변환 하는 것도 가능하다.
    
    인스턴스가 메모리에 있는 것을 생각해보면 이해할 수 있다. 참조 변수만 바뀔 뿐 원래 생성된 인스턴스는 그대로라는 것.
    

## III. 활용

- **은닉화**
    
    **캡슐화**는 은닉화를 전제로 한다.
    
    은닉화는 변수에 직접적인 접근을 막는 것.
    
    getter, setter을 통해 변수에 접근하게 하는 일종의 패턴이다.
    
    setter의 경우 변수의 타입에는 문제되지 않는 값이 들어가도 함수의 invariant property에 어긋날 수 있기 때문에 한 층의 필터가 될 수 있다.
    
- **객체를 확인하는 방법**
    
    **instanceof**를 사용해서
    
    {ObjectName} instanceof {ClassName}
    
    {ObjectName} instanceof {InterfaceName}
    
    이런 식으로 체크할 수 있다.
    
- **자바 Class 클래스**
    
    Class 클래스는 컴파일된 .class 파일에서 객체의 정보를 가져올 수 있다.
    
    Class pClass = Class.forName(”className”);
    
    **동적 로딩**
    
    컴파일 타임에 체크할 수 없어서 런타임에서 ClassNotFoundException이 발생할 수 있다.
    
    소스 코드 없이 클래스만 제공(.class) 받아 사용할 경우에도 많이 사용된다.
    
- **절차지향과 객체지향**
    
    프로그래밍 방식의 종류
    
    상반되는 개념이 아니다.
    
    절차지향 : C
    
    객체지향 : Java, C++, C#, Python
    
    절차지향 : 데이터를 중심으로 함수를 구성한다. 함수의 호출 순서가 틀려서도 안된다. (데이터의 전달과 값이 변할 수 있다.) 하나가 고장나면 전체 기능이 마비된다.
    
    객체지향 : 제작에 있어서 순서적이지 않아도 된다. 각각 독립적으로 개발되어 나중에 한 곳에 모여 자신의 기능만 제대로 발휘하면 된다.(책임) 고장 나면 고장 난 부품만 고쳐주면 된다. 필요하면 부품을 다른 것으로 교체할 수 있다.